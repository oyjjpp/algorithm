### 题目

（509）. 斐波那契数

#### 题目描述

斐波那契数，通常用F(n)表示，形成的序列称为斐波那契数列；该数列由0和1开始，后面的每一项数字都是前面两项数字的和。  
也就是：

```golang
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

### 思路

#### 方案一

题目中已经提供算法原型  
F(N) = F(N - 1) + F(N - 2)  
但是此算法运算很低效，存在大量重复的运算，也就是说递归问题的三要素“重叠子问题”

#### 方案二

算法原型还是方案一的算法，主要解决方案一中大量重复运算引起的“重叠子问题”  
通过备忘录方式解决重复运算问题，以空间换时间的优化方案  
代码中使用map将已经计算的结果存储起来，待下次使用时，直接读取，而不用在重复计算

#### 方案三

斐波那契数列 通过DP table解决重叠子问题  
自底向上计算的实现  
我们直接从最底下，最简单，问题规模最小的f(1)和f(2)开始往上推，直到推到我们想要的答案f(20)，  
这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。  

#### 方案四

斐波那契数列 通过DP table解决重叠子问题  
自底向上计算的实现  
我们直接从最底下，最简单，问题规模最小的f(1)和f(2)开始往上推，直到推到我们想要的答案f(20)，  
算法中状态转移f(n) = f(n-1)+f(n-2)，计算中仅需要使用两个状态，上面都是使用map保存了所有状态  
此类问题我们可以通过“状态压缩”，减少内存的浪费  

### 代码

```golang

```

### 参考

来源：力扣（LeetCode）  
链接：<https://leetcode-cn.com/problems/fibonacci-number//>  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
